module fr.labri.patterndetector.lang.Parser;

header {
    import java.util.concurrent.TimeUnit;

    import fr.labri.patterndetector.lang.AST.*;
    import static fr.labri.patterndetector.lang.AST.*;
}

body {
    Rule _currentRule;
}

public Pair<Rule> script
    = rule (EOL rule)* EOL? EOF
    ;

Rule rule
    = n:SYMBOL n COLON n { Rule r = newRule(n);  _currentRule = r; }
    ((((m:match { _currentRule.appendPattern(m); })+ (c:condition { _currentRule.appendConstraint(c); })*)
    / (c:condition { _currentRule.appendConstraint(c); })+) EOL)*
    {yyValue = r; }
    ;

Constraint condition
    = CONDITION ( function / binary )
    ;

void function
    = SYMBOL args
    ;

void binary
    = arg operator arg
    ;

Pattern match
    = p:pattern n tl:(transition n)* { p.addTransitions(tl); } (s:sequence  n ntl:(transition* n) { p = newKleene(p); p.addAlias(s); p.addTransitions(ntl); })? { yyValue = p; }
    ;

Transition transition
    = '[' function ']' {yyValue = newTransition();}
    / SLASH restricted_match SLASH {yyValue = newNak();}
    ;

void restricted_match
    = SYMBOL
    ; // TODO restricted_match

Pattern pattern
  = s:SYMBOL n { Pattern p = newSimplePattern(s); } (COLON n a:SYMBOL n { p.addAlias(a); })? { yyValue = p; }
  / '(' n m:match* { Pattern p = newCompositePattern(m); } ')' n (COLON s:SYMBOL n { p.addAlias(s); })? { yyValue = p; }
  / REFERENCE n s:SYMBOL n { yyValue = newReferencePattern(s); }
  ;

String sequence
    = KLEENE {yyValue = null;} (COLON yyValue:SYMBOL)?
    ;

void args
    = arg (',' arg)*
    ;

void arg
    = literal
    / selector
    ;

void selector
    = SYMBOL range? ('.' selector)*
    ;

void range
    = '[' range_spec ']'
    ;

void range_spec
    = simple_arith (RANGE simple_arith?)?
    / RANGE simple_arith
    ;

void simple_arith
    = (SYMBOL / number) (arith_symbol SYMBOL/number)?  // TODO Parentesis
    ;

void literal
    = number
    / STRING
    / timeunit
    ;

void number
    = DECIMAL
    / HEX
    ;

TimeValue timeunit
    = v:(DECIMAL / HEX)
    ([dD] { yyValue = newTimeValue(v, TimeUnit.DAYS); }
    / [hH] { yyValue = newTimeValue(v, TimeUnit.HOURS); }
    / [mM][sS] { yyValue = newTimeValue(v, TimeUnit.MILLISECONDS); }
    / [uU][sS] { yyValue = newTimeValue(v, TimeUnit.MICROSECONDS); }
    / [nN][sS] { yyValue = newTimeValue(v, TimeUnit.NANOSECONDS); }
    / [mM] { yyValue = newTimeValue(v, TimeUnit.MINUTES); }
    / [sS] { yyValue = newTimeValue(v, TimeUnit.SECONDS); })
    ;

String KLEENE = '+';
String SLASH = '/' ;

String STRING = ["] (!["\\] _)* ["] ;

String operator
    = arith_symbol
    / ">=" / "<=" / '>' / '<' / '=' / "!="
    ;

String arith_symbol
    = '-' / KLEENE / '*' / SLASH
    ;

String RANGE = "..";

String SYMBOL = ([a-zA-Z][a-zA-Z0-9]*/[a-zA-Z0-9_]+);

void REFERENCE = '@';

String digit = [0-9];
String DECIMAL = digit+;

String hex_digit = [0-9a-fA-F] ;
String HEX = "0x" hex_digit+;

String COLON = ':';
String CONDITION = '#';

transient void n   = (Space / SLComment / MLComment)*;
transient void nn  = (Space / SLComment / MLComment)+;
transient void Space     = ' ' / '\t' / '\f';
transient void SLComment = "//" (![\n\r] _)* EOL;
transient void MLComment = "/*" (MLComment / !"*/" _)* "*/";
transient void EOL       = '\r' '\n' / '\r' / '\n';
transient void EOF       = !_;
